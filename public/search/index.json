[{"content":"CuprumTurbo Scheduler V20 性能前瞻\r叠甲\rGitHub地址：https://github.com/chenzyadb/CuprumTurbo-Scheduler CuprumTurbo Scheduler 作者为@chenzyadb\nV20相对于V19的改动\r与V19版本相比新版本引入了setProperty,这个东西有什么用呢？ 简单翻译一下,就是设置属性\n那么在CT中有什么用呢？\n诶，以往的配置文件结构中，各个模块的功能是分开的，比如CpuGovernor，ThreadSchedOpt，MtkGpuGovernor 各个模块之间的参数和模式都是预设好的，模块之间是相互独立的，现在你可以简单理解为动态调整属性\n举个例子，CPU频率加速,触发条件包含tap swipe gesture heavyload jank bigJank,分别在 点击屏幕 滑动屏幕 手势操作 重负载 掉帧 严重掉帧 时触发.在v19中这些条件对应的boots和extraMargind的值是固定,而在v20中你可以通过setProperty来动态调整这些参数,boots,extraMargin,gpuFreq,ddr,都可以通过setProperty来调整,相对的配置文件也超过了1000行\n比较容易理解的例子就是,当cpu温度过高时，降低powelinmit,来达到限制功耗的目的，最早在V18中出现过，V19就改了\n测试\r测试环境:红米K60 Ulatr,HyperOS 1.0.22,CTv20 Alpha\n游戏:当然是原神啦\n内容：且试身手琳尼试用 5分钟 连续挑战打怪\nPS:感觉这样对比会更好一点，起码相对跑图来说.\n这是一张拼接过的图，很大，建议保存下拉看 功耗对比\r相对于V19,功耗可能有些下降，你问问我为什么这么说，我也不知道，我只是感觉到了\n不得不说还是内核态更好一点jank都少\n可能你也发现了，第一列和第六七列分别为官调和V20，功耗都是最低的，为什么呢，要不是一开始调度没跑起来，我都以为是V20了， 经过仔细观察，得益于官调锁？GPU频率350左右，奶奶滴玩阴的是吧 看CT这边 只能说 6 然后就得到了第一列这个极低功耗下的结果，当然功耗也来到了5.3w CPU频率曲线\u0026amp;Cycles\r总结\r结语\r","date":"2024-11-24T19:42:21+08:00","image":"https://raw.gitcode.com/NightRainMilkyWay/PicPlus/files/main/img/107553243_p0.jpg","permalink":"http://localhost:1313/p/custom-block/","title":"CuprumTurbo Scheduler V20 性能前瞻"},{"content":"标题语法\r一级标题\r二级标题\r三级标题\r四级标题\r五级标题\r六级标题\r强调语法\r粗体（Bold）\rI just love bold text.\n斜体（Italic）\rI just love bold text.\n粗体（Bold）和斜体（Italic）\rI just love bold text.\n引用语法\r1 \u0026gt; Dorothy followed her through many of the beautiful rooms in her castle. Dorothy followed her through many of the beautiful rooms in her castle.\n多个段落的块引用\r1 2 3 \u0026gt; Dorothy followed her through many of the beautiful rooms in her castle. \u0026gt; \u0026gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood. Dorothy followed her through many of the beautiful rooms in her castle.\nThe Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.\n嵌套块引用\r1 2 3 \u0026gt; Dorothy followed her through many of the beautiful rooms in her castle. \u0026gt; \u0026gt;\u0026gt; The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood. Dorothy followed her through many of the beautiful rooms in her castle.\nThe Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood.\n带有其它元素的块引用\r1 2 3 4 5 6 \u0026gt; #### The quarterly results look great! \u0026gt; \u0026gt; - Revenue was off the chart. \u0026gt; - Profits were higher than ever. \u0026gt; \u0026gt; *Everything* is going according to **plan**. The quarterly results look great!\rRevenue was off the chart. Profits were higher than ever. Everything is going according to plan.\n列表语法\r有序列表\rFirst item Second item Third item Fourth item 无序列表\rFirst item Second item Third item Fourth item 套嵌使用\rFirst item Second item Third item Indented item Indented item Fourth item 1 2 3 4 5 6 7 8 9 This is a regular paragraph. \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;Foo\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; This is another regular paragraph. ","date":"2024-11-24T19:42:21+08:00","image":"https://raw.gitcode.com/NightRainMilkyWay/PicPlus/files/main/img/107553243_p0.jpg","permalink":"http://localhost:1313/p/custom-block/","title":"MarkDown语法"},{"content":"准备\r本源码需要配合Clion使用,keil等代码编辑器可能存在语法错误\r代码中注释了部分功能,可以自行尝试\n环境配置\r下载安装Clion\n安装 PlatformIO 插件\n在clion中新建一个项目，根据提示配置环境\n编写一个简单的代码测试环境是否配置成功\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;mcs51/8052.h\u0026gt; void main() { while(1) { P1 = 0xfe; } } 环境配置文件(以stc89c52rc为例)\r1 2 3 4 5 6 [env:STC89C52RC] platform = intel_mcs51 board = STC89C52RC lib_deps = C:\\Users\\Night\\.platformio\\packages\\toolchain-sdcc\\include // 这里配置环境安装路径 原理图\rled电路图\r蜂鸣器\r7Ch138译码器\r或非门\r数码管\r延时函数\r1 2 3 4 5 6 7 8 9 10 11 12 // 延时函数 void Delay(unsigned int time) { while (time--) { DisplaySMG_Dynamic(); } } // 延时函数 void DelaySMG(unsigned int time) { while (time--) ; } 定时器函数\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // Timer 0 interrupt service routine void timer0_ISR() __interrupt(1) { TH0 = 0xFC; // Reload high byte for 1ms TL0 = 0x66; // Reload low byte for 1ms } } // Initialize Timer 0 void Timer0_Init() { TMOD |= 0x01; // Set Timer 0 in mode 1 (16-bit timer mode) TH0 = 0xFC; // Load initial value for 1ms delay TL0 = 0x66; ET0 = 1; // Enable Timer 0 interrupt EA = 1; // Enable global interrupts TR0 = 1; // Start Timer 0 } 数码管位选和段选函数\r1 2 3 4 5 6 7 8 9 10 11 12 13 // 选择位 void SelectBit(unsigned char pos) { Init74HC138(6); // Open COM end P0 = 0x00; // Turn off all segments DelaySMG(10); // Short delay to eliminate shadow P0 = (0x01 \u0026lt;\u0026lt; pos); } // 选择段 void SelectSegment(unsigned char value) { Init74HC138(7); // 打开段选端 P0 = value; } 74HC573锁存器函数\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void int74h573(unsigned int n) { switch (n) { case 4: P2 = (P2 \u0026amp; 0x1f) | 0x80; break; case 5: P2 = (P2 \u0026amp; 0x1f) | 0xa0; break; case 6: P2 = (P2 \u0026amp; 0x1f) | 0xc0; break; case 7: P2 = (P2 \u0026amp; 0x1f) | 0xe0; break; } } 动态显示数码管\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 动态显示数码管 void DisplaySMG_Dynamic() { SelectBit(0); SelectSegment(SMG_NoDot[hour / 10]); DelaySMG(500); SelectBit(1); SelectSegment(SMG_NoDot[hour % 10]); DelaySMG(500); SelectBit(2); SelectSegment(SMG_NoDot[16]); DelaySMG(500); SelectBit(3); SelectSegment(SMG_NoDot[minute / 10]); DelaySMG(500); SelectBit(4); SelectSegment(SMG_NoDot[minute % 10]); DelaySMG(500); SelectBit(5); SelectSegment(SMG_NoDot[16]); DelaySMG(500); SelectBit(6); SelectSegment(SMG_NoDot[second / 10]); DelaySMG(500); SelectBit(7); SelectSegment(SMG_NoDot[second % 10]); DelaySMG(500); } 完整代码 mian.c\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include \u0026#34;mcs51/8052.h\u0026#34; #include \u0026#34;tool.h\u0026#34; typedef unsigned int u16; unsigned int ms_count = 0; // Millisecond counter // Timer 0 interrupt service routine void timer0_ISR() __interrupt(1) { TH0 = 0xFC; // Reload high byte for 1ms TL0 = 0x66; // Reload low byte for 1ms ms_count++; if (ms_count \u0026gt;= 1000) { // 1000ms = 1 second ms_count = 0; time_increase(); DisplaySMG_Dynamic(); } } // Initialize Timer 0 void Timer0_Init() { TMOD |= 0x01; // Set Timer 0 in mode 1 (16-bit timer mode) TH0 = 0xFC; // Load initial value for 1ms delay TL0 = 0x66; ET0 = 1; // Enable Timer 0 interrupt EA = 1; // Enable global interrupts TR0 = 1; // Start Timer 0 } // Main function int main() { Timer0_Init(); // Initialize Timer 0 while (1) { DisplaySMG_Dynamic(); // Display dynamic SMG } } tool.h\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // // Created by NightRain on 2024/11/18. // #ifndef UNTITLED1_TOOL_H #define UNTITLED1_TOOL_H void DisplaySMG_Dynamic(); void Delay(unsigned int time); void DelaySMG(unsigned int time); void Init74HC138(unsigned char n); void SelectBit(unsigned char pos); void SelectSegment(unsigned char value); void time_increase(); #endif // UNTITLED1_TOOL_H tool.c\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 // // Created by NightRain on 2024/11/18. // #include \u0026#34;tool.h\u0026#34; #include \u0026#34;mcs51/8052.h\u0026#34; // 共阳4位数码管的段码数组 unsigned char SMG_NoDot[18] = {0xc0, 0xf9, 0xa4, 0xb0, 0x99, 0x92, 0x82, 0xf8, 0x80, 0x90, 0x88, 0x80, 0xc6, 0xc0, 0x86, 0x8e, 0xbf, 0x7f}; unsigned int hour = 0; unsigned int minute = 0; unsigned int second = 0; void DisplaySMG_Dynamic(); void Delay(unsigned int time); void DelaySMG(unsigned int time); void Init74HC138(unsigned char n); void SelectBit(unsigned char pos); void SelectSegment(unsigned char value); // 延时函数 void Delay(unsigned int time) { while (time--) { DisplaySMG_Dynamic(); } } // 延时函数 void DelaySMG(unsigned int time) { while (time--) ; } // 选择通道，即具体选择哪个锁存器 void Init74HC138(unsigned char n) { switch (n) { case 4: P2 = (P2 \u0026amp; 0x1f) | 0x80; break; case 5: P2 = (P2 \u0026amp; 0x1f) | 0xa0; break; case 6: P2 = (P2 \u0026amp; 0x1f) | 0xc0; break; case 7: P2 = (P2 \u0026amp; 0x1f) | 0xe0; break; } } void int74h573(unsigned int n) { switch (n) { case 4: P2 = (P2 \u0026amp; 0x1f) | 0x80; break; case 5: P2 = (P2 \u0026amp; 0x1f) | 0xa0; break; case 6: P2 = (P2 \u0026amp; 0x1f) | 0xc0; break; case 7: P2 = (P2 \u0026amp; 0x1f) | 0xe0; break; } } // 选择位 void SelectBit(unsigned char pos) { Init74HC138(6); // Open COM end P0 = 0x00; // Turn off all segments DelaySMG(10); // Short delay to eliminate shadow P0 = (0x01 \u0026lt;\u0026lt; pos); } // 选择段 void SelectSegment(unsigned char value) { Init74HC138(7); // 打开段选端 P0 = value; } void time_increase() { second++; if (second == 60) { second = 0; minute++; if (minute == 60) { minute = 0; hour++; if (hour == 24) { hour = 0; } } } } // 动态显示数码管 void DisplaySMG_Dynamic() { SelectBit(0); SelectSegment(SMG_NoDot[hour / 10]); DelaySMG(500); SelectBit(1); SelectSegment(SMG_NoDot[hour % 10]); DelaySMG(500); SelectBit(2); SelectSegment(SMG_NoDot[16]); DelaySMG(500); SelectBit(3); SelectSegment(SMG_NoDot[minute / 10]); DelaySMG(500); SelectBit(4); SelectSegment(SMG_NoDot[minute % 10]); DelaySMG(500); SelectBit(5); SelectSegment(SMG_NoDot[16]); DelaySMG(500); SelectBit(6); SelectSegment(SMG_NoDot[second / 10]); DelaySMG(500); SelectBit(7); SelectSegment(SMG_NoDot[second % 10]); DelaySMG(500); } ","date":"2024-11-13T17:33:49+08:00","image":"https://img.nightrainmilkyway.cn/img/202411182015900.jpg","permalink":"http://localhost:1313/p/stc51_1/","title":"国信长天单片机"},{"content":"Tritium box\r高性能调度\n什么是Tritium box? Tritium是一个基于CuprumTurbo Schedule调度修改的项目，而Tritium box是一个基于Tritium的项目，如果你不知道什么是CuprumTurbo Schedule，但你肯定听所过CT\n具体详细见我们的网站：https://tritium.nightrainmilkyway.cn 如何使用：https://tritium.nightrainmilkyway.cn/guide/use 该项目已开源，欢迎PR star 项目地址：https://github.com/TimeBreeze/Tritium_box 下载链接： GitHub Release Alist 网盘 详细介绍\r关于 Tritium box，与scene，cutoolbox不同的，我们去掉了状态栏通知常驻，因为我感觉很不好，现在可以通过在控制中心中添加应用快捷开关，一共有4个，你可以将他们固定，每次且切换只需要，通过控制中心，减去了状态栏常驻，我认为这是美观的，就像手机自带的那样切换模式\n关于\r是的，这个背景是基于轻语陌落亚托利亚主题的背景图片，我感觉很好看，所以就用了，拿来用了，(已经过作者同意)，毕竟我们调度也是高性能的\n其他问题 有一些小bug，不影响使用，留到下一次commit吧，主要是关于主题取色，为什么你们有的取色真的好奇怪\n附录\r参考文献\r版权信息\r本文原载于 nightrainmilkyway.cn，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-11-13T17:33:49+08:00","image":"https://img.nightrainmilkyway.cn/img/202411162031086.jpg","permalink":"http://localhost:1313/p/first_app/","title":"记录第一次写APP"},{"content":"域名解析系统发展史\r早期互联网和主机文件（HOSTS.TXT）\r在DNS出现之前，互联网的域名解析依赖于一个中心化的文件：HOSTS.TXT。这个文件由斯坦福研究所（SRI）的Network Information Center (NIC) 维护，列出了每个域名对应的IP地址。每台计算机必须手动下载并更新这个文件才能进行域名解析。\n随着互联网的发展和联网设备数量的增加，这种方法逐渐显得低效和不可扩展。尤其是随着互联网向全球化发展，HOSTS.TXT文件变得过大且更新频繁，无法满足需求。\n为了应对早期域名解析方案的局限性，Paul Mockapetris在1983年提出了DNS系统的概念并编写了最初的DNS协议规范（RFC 882 和 RFC 883，后被更完善的RFC 1034 和 RFC 1035替代）。DNS的核心思想是通过一个分布式、层级化的系统来进行域名解析，解决了HOSTS.TXT文件集中管理带来的扩展性问题\n域名空间的扩展 (1980年代后期)\r随着DNS的推出，顶级域名（TLDs）逐渐被引入，并按照不同的用途分类：\n通用顶级域名（gTLDs）：如 .com（商业组织）、.org（非营利组织）、.edu（教育机构）、.net（网络相关）。\n国家顶级域名（ccTLDs）：如 .cn（中国）、.uk（英国）等，专门为各国或地区保留。\n小贴示\n域名系统采用层次化结构，其中每一级用“.”符号分隔。根据域名的层级关系，域名可以分为顶级域名（TLD）、二级域名、三级域名等多级域名。下面详细介绍域名的层级划分：\n顶级域名 (TLD) 顶级域名是域名结构的最高层级，位于域名最右边。TLD通常由ICANN（互联网名称与数字地址分配机构）管理。顶级域名分为以下几类：\n通用顶级域名 (gTLDs)： 这些是最常见的顶级域名，用于特定用途或类型的网站：\n.com：最初为商业机构设计，现在广泛用于各种网站。\n.org：用于非营利组织，但也被许多其他组织采用。\n.net：最初为网络服务提供商设计，现在广泛使用。\n.edu：用于美国的教育机构。\n.gov：用于美国政府部门。\n.mil：用于美国军事机构。 国家顶级域名 (ccTLDs)： 每个国家或地区都有专门的顶级域名，以两个字母代码表示。常见的 ccTLD 包括：\n.cn：中国\n.uk：英国\n二级域名 二级域名是位于顶级域名之下的下一级域名，通常是组织或企业的名字，用来标识特定的组织、公司或个人。例如：\n在www.example.com中，example是二级域名。\n在www.google.cn中，google是二级域名。\n二级域名通常由域名持有者根据其需求自定义，它们可以是企业名称、品牌、服务类型或其他识别符\n三级域名及多级域名 三级域名是位于二级域名之下的域名。三级及多级域名通常用于区分子站点、服务或功能。例如：\nwww：是一个常见的三级域名，表示网页服务（World Wide Web mail.google.com：mail是三级域名，表示谷歌的邮件服务（Gmail）\nDNSSEC 的引入 (1990年代末 - 2000年代)\r虽然DNS系统设计得非常灵活，但随着互联网的快速发展，安全问题逐渐显现。DNS系统缺乏对解析数据真实性的验证机制，容易受到攻击，如DNS欺骗（DNS Spoofing）和中间人攻击。\n为了解决这些问题，DNSSEC（Domain Name System Security Extensions，域名系统安全扩展）在1990年代末提出，并在2000年代开始逐渐推广。DNSSEC通过对DNS记录进行数字签名，确保解析结果的真实性和完整性，防止恶意篡改。\n根域名服务器的全球部署\rDNS的根域名服务器是DNS体系中最顶层的服务器，最初只在美国部署。但为了提高DNS的可靠性和性能，根域名服务器逐渐被扩展到全球范围内。目前有13组根域名服务器，由不同的组织和公司管理，这些服务器分布在多个国家和地区，通过Anycast技术保证全球用户能够快速访问。 小贴示\n为什么DNS根服务器只能有13台？\rDNS协议的限制：DNS系统最早的设计是在1980年代，那个时候的互联网协议（如IPv4）和硬件性能都相对有限。DNS查询时使用的是UDP数据包，最大包大小为512字节。在这个限制下，返回给客户端的DNS查询结果列表必须足够小，以免超出512字节的限制\n根服务器IP地址的数量：在DNS系统中，客户端查询根域名时需要获取根域名服务器的IP地址列表。DNS解析器通过“根提示文件”（root hints file）来获取所有根服务器的IP地址信息。13个根服务器的IP地址列表恰好能适应这个512字节的限制。\n国际化域名 (IDN) 的引入\r随着全球互联网用户数量的增长，尤其是非英语国家用户的增加，使用仅支持ASCII字符的域名系统逐渐显得不足。为了支持更多的语言字符，国际化域名（IDN）在2000年代引入，允许使用非拉丁字符的域名（如中文、阿拉伯文、韩文等）\n附录\r参考文献\r为什么全球域名根服务器只能有13台？加一台给中国很难吗？\n版权信息\r本文原载于 nightrainmilkyway.cn，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-09-26T19:37:23+08:00","image":"https://img.nightrainmilkyway.cn/img/ResizedImage_2024-09-24_21-39-25_1.webp","permalink":"http://localhost:1313/p/dns/","title":"修改hosts文件理解DNS - （下）"},{"content":"Git Flow是什么？为什么需要它\r当同一个项目中的开发人员越来越多时，如果没有制定好规则，放任大家由着自己的习惯随便Commit的话，迟早会造成灾难。 早在2010年的时候，就有人提出了一套流程，或者说一套规则供大家共同遵守（网址：http:/nvie.com/posts/a-successful-git-branching-model/)。之后，一些比较优秀的开发流程相继问世，如GitHub Flow、Gitlab Flow 等。这里仅以Git Flow 为例进行介绍。\n1.分支应用情境\r根据Git Flow 的建议，分支主要分为Master分支、Develop分支、Hotfix分支、Release分支以及Feature分支，各分支负责不同的功能，如图11-1所示。其中Master分支和Develop分支又被称为长期分支，因为它们会一直存在于整个Git Flow中，而其他的分支大多会因任务结束而被删除。\nMaster 分支。Master 分支主要是用来存放稳定、随时可上线的项目版本。这个分支的来源只能是从别的分支合并过来的，开发者不会直接Commit 到这个分支。因为是稳定版本，所以通常会在这个分支的Commit上打上版本号标签。 Develop分支。Develop分支是所有开发分支中的基础分支，当要新增功能时，所有的Feature 分支都是从这个分支划分出去的。而Feature分支的功能完成后，也会合并到这个分支。 Hotfix分支。当在线产品发生紧急问题时，会从Master分支划出一个Hotfx分支进行修复。Hotfix分支修复完成之后，会合并回Master分支，同时合并一份到Develop分支。 为什么要合并回Develop分支？因为如果不这样做，等到Develop分支完成且合并回Master分支时，之前的问题就会再次出现。 那为什么一开始不从Develop分支划分出去修？因为Develop分支的功能可能尚在开发中，这时如果硬要从这里切出去修复再合并回Master分支，只会造成更大的灾难。 Release分支。当认为Develop分支足够成熟时，就可以把Develop分支合并到Release分支,在其中进行上线前的最后测试。测试完成后，Release分支将会同时合并到Master 及Develop这两个分支中。Master分支是上线版本，而合并回Develop分支，是因为可能在Release分支上还会测到并修正一些问题，所以需要与Develop分支同步，以免之后的版本再度出现同样的问题。 Feature分支。如果要新增功能，就要使用Feature分支了。Feature分支都是从Develop分 支划分出来的，完成之后会合并回Develop分支。 附录\r参考文献\rGit Flow - 菜鸟教程\n版权信息\r本文原载于 nightrainmilkyway.cn，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-09-24T21:36:55+08:00","image":"https://img.nightrainmilkyway.cn/img/ResizedImage_2024-09-24_21-39-26_2.webp","permalink":"http://localhost:1313/p/git-flow/","title":"Git Flow是什么？为什么需要它"},{"content":"hosts 是什么？\r相信大家都看过流浪地球 2，其中有这么一个情节，重启世界根服务器，那么这个根服务器到底是什么呢？这里就不得不提及域名解析系统的发展史了 在很早很早以前，域名解析系统还没有建立起来，全球的网络主机还很少的时候，IP 地址的映射主要靠的就是各主机里的 hosts 文件来实现，那时候的 hosts 文件保存着互联网上所有主机地址的映射。而 hosts 文件的更新是由一个专门来维护 hosts 文件的站点来实现。也就是说那时根本就不需要也没有 DNS 服务器这东西，用自己主机上的 hosts 文件就可以找到对方的 IP 地址然后建立连接了\n但是后来随着互联网的规模不断扩大，hosts文件的维护也越来越困难，毕竟全球的网络主机都需要通过这个负责维护 hosts 更新站点来更新，hosts 所存放的解析记录数量级不断增加，单单只是检索就要花不少时间 修改hosts文件理解DNS - （下）\n当我们打开这个hosts文件之后可以发现里面有一下内容\nWindows 目录是: C:\\Windows\\System32\\drivers\\etc\\hosts\nLinux 目录是: /etc/hosts\n1 2 3 4 5 6 7 8 9 10 11 12 13 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback ff02::1 ip6-allnodes ff02::2 ip6-allrouters 20.205.243.166　github.com 61.91.161.217\twww.google.com 61.91.161.217\tgoogle.com 61.91.161.217\tgcr.io 61.91.161.217\twww.gcr.io 61.91.161.217\tcom.google 61.91.161.217\tadmin.google.com 61.91.161.217\taccounts.google.com 61.91.161.217\taccounts.google.cn 看到第一行就是我们所熟悉的127.0.0.1　localhost，就是在hosts中定义的\n可以看第 5 行前面是 IP 后面是域名一一对应，是不是突然就明白了这个hosts文件的作用\nDNS 是什么\rDNS（Domain Name System，域名系统），将人类可读的域名（例如 www.example.com）转换为机器用于相互通信的IP地址（例如 192.0.2.1 或 2001:db8::1）的一种分布式数据库。打个比方来说，DNS就像一个电话簿，IP相当于电话号码，域名相当于联系人\n小贴示\n这几条可以看出一个 IP 地址可以同时对应多个域名，这也就是为什么平时在地址栏上输入 google.com或www.google.com都可以访问 google 了。而https://是浏览器自动帮你加上去的，平时我们访问不了 google 的原因是，google 的域名 在本机转化为 IP 地址后经过中国大陆的防火长城，被防火长城检测到与黑名单内的关键词匹配（如：Google、Facebook、twitter等都在黑名单内），然后就会伪装成目标域名的解析服务器返回虚假的查询结果。关键的是通常的域名查询没有任何认证机制，而且域名的查询一般是基于无连接不可靠的 UDP 协议，所以浏览器只能接受最先到达的格式正确结果，并把之后的所有结果丢弃。所以这也就访问不了啦，这种情况就是所谓的 DNS 缓存污染，也称为 DNS 缓存投毒（这个真形象…）参考文献-从修改hosts文件科学上网中理解DNS（上）\n一个域名背后可以有多个I地址。当域名解析服务器在解析域名记录的“值”中包含多个IP地址时，LDNS会返回所有IP地址，但返回I地址的顺序是随机的。浏览器默认选取第一个返回的 IP地址作为解析结果，其解析流程如下。\n网站访问者通过浏览器向Local DNS（简称LDNS）发送解析请求。 LDNS将解析请求逐级转发（递归）至权威DNS。 权威DNS在收到解析请求后，将所有I地址以随机顺序返回LDNS。 LDNS将所有IP地址返回浏览器。 网站访问者的浏览器随机访问其中一个I地址，通常（不是绝对）选取第一个返回的IP地址。在没有做反向代理的情况下，如果返回的IP地址有多个，那么访问到这些IP地址的机会一般是均等的。 在DNS解析的描述过程中，浏览器首先通过本地的DNS服务（LDNS）发送第一个 解析请求，然后由LDNS返回IP地址，访问对应的服务器所提供的互联网服务。 这样就带来了一个问题：如果LDNS返回的不是公网的域名解析服务解析出的IP地址， 而是经过本地篡改的呢？\n域名篡改\r域名会被篡改吗？或域名解析服务器在解析域名后返回的IP地址会被篡改吗？ 在回答上述问题前，我们先查看Linux系统中有关DNS的配置文件。\n引言\n/etc/hosts：记录hostname对应的IP地址 /etc/resolv.conf：设置DNS服务器的IP地址 /etc/host.conf：指定域名解析的顺序，是先从hosts 解析还是先从DNS解析\nLDNS 优先解析hosts 文件（Windows 路径是C：\\Windows\\System32\\driversletclhosts）,在hosts文件中，改变域名指向的I地址，我们将不会访问到原来的公网主机。示例如下：\n1 [root@linuxido ~]# ping linuxido.com({}) →在修改前，对城名执行ping命令\n1 2 3 PING linuxido.com (123.56.94.254) 56(84) bytes of data. 64 bytes from 123.56.94.254 (123.56.94.254): icmp _seq=1 ttl=53 time=25.6 ms [root@linuxido ~l# dig +short linuxido.com →使用dig命令解析域名\n1 2 3 4 5 123.56.94.254 ##→修改域名对应的IP地址 [root@linuxido~]# echo \u0026#39;120.120.120.120 linuxido.com\u0026#39; \u0026gt;\u0026gt; /etc/hosts [root@linuxido~]# ping linuxido.com →修改后，再对域名执行ping命今\n1 2 PING linuxido.com (120.120.120.120) 56(84) bytes of data. 并→可以看到ping命令失败，无法ping通120.120.120.120 →使用host命令解析城名，可以看到依然是公网IP地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 [root@linuxido~l# host linuxido.com linuxido.com has address 123.56.94.254[root@linuxido ~]# nslookup linuxido.com Server: Address: 8.8.8.8 8.8.8.8#53 Non-authoritative answer: Name: linuxido.com Address: 123.56.94.254 [root@linuxido ~]# dig linuxido.com linuxido.com. 599 IN A 123.56.94.254 ##一修改hosts 文件后，dig命令解析的城名依然是公网IP地址。找寻A的记录，它是不经过LDNS iSERVER:8.8.8.8#53（8.8.8.8) ##→本机的DNS地址设置为8.8.8.8，DNS的默认端口是53 如果没有修改 hosts 文件，在什么情况下可能出现DNS返回错误的IP 地址呢？域名劫持是最可能出现的情况。域名劫持就是通过攻击或伪造域名解析服务器的方式，把目标网站域名解析到错误的 I地址，从而使用户访问一些非法、恶意网站。因此，我们需要使用域名解工具查看访问域名是都真正对应IP地址\nDNS污染\r小贴示\n网域服务器缓存污染（英语：DNS cache pollution）、DNS污染或DNS劫持，是一种破坏域名系统查询解析的行为。[1]通常有计算机程序自动执行DNS劫持攻击导致DNS服务器缓存了错误记录的现象。而域名服务器缓存投毒（DNS cache poisoning）和DNS缓存投毒指由计算机程序执行的DNS劫持攻击。污染一词可能取自域名系统域名解析之特性，若递归DNS解析器查询上游时收到错误回复，所有下游也会受影响 参考文献（3）-域名服务器缓存污染\nhosts是如何实现科学上网的\r这里以GitHub为例\n1 20.205.243.166　github.com GitHub站点毕竟在国外，当dns请求时返回最快的那一个IP，但是想要访问就肯定要走大陆宽带，防火长城就会返回一个假的结果，那么hosts为什么能直接连上GitHub呢，这里就不得不提及域名解析的优先级了，hosts \u0026gt; DNS，在DNS域名解析系统建立起来之后hosts被弃用，但仍然保留在Linux，Windows系统内，而且优先级一般大于dns解析结果，从而能够建立连接\n当然，如果想流畅的访问GitHub单单只是修改hosts效果并不明显，可以搭配FastGithub合法的工具访问 附录\r参考文献\r参考文献（1）-从修改hosts文件科学上网中理解DNS（上）\n参考文献（2）-Linux从入门到精通 第八章 Linux网络与安全\n参考文献（3）-域名服务器缓存污染\n版权信息\r本文原载于 nightrainmilkyway.cn，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-09-23T10:08:44+08:00","image":"https://img.nightrainmilkyway.cn/img/122622935_p0 (1).png","permalink":"http://localhost:1313/p/%E4%BF%AE%E6%94%B9hosts%E6%96%87%E4%BB%B6%E7%90%86%E8%A7%A3dns-%E4%B8%8A/","title":"修改hosts文件理解dns - (上)"},{"content":"前言\r上篇文章讲了如何在termux上快速安装arch linux，然后就可以玩一些好玩的，Google发行的NDK并不支持ARM架构\n下载NDK\r在Android开发者网站上下载NDK，下载地址为：https://developer.android.com/ndk/downloads 然后解压到root目录下\n1 unzip android-ndk-r27b-linux.zip 然后安装zip工具链并新建一个test目录\n1 2 pacman -S zip \u0026amp;\u0026amp; mkdir test \u0026amp;\u0026amp; cd test \u0026amp;\u0026amp; touch test.sh 并填入以下内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #!/bin/sh set -eu TEST_DIR=\u0026#34;$(dirname \u0026#34;$(realpath \u0026#34;$0\u0026#34;)\u0026#34;)\u0026#34; ## ndk clang resource dir, get by command: \u0026lt;ndk_root\u0026gt;/toolchains/llvm/prebuilt/linux-x86_64/bin/clang --print-resource-dir RESOURCE_DIR=\u0026#34;${TEST_DIR}/../android-ndk-r27b/toolchains/llvm/prebuilt/linux-x86_64/lib/clang/18/\u0026#34; ## ndk sysroot, typically \u0026lt;ndk_root\u0026gt;/toolchains/llvm/prebuilt/linux-x86_64/sysroot/ SYSROOT=\u0026#34;${TEST_DIR}/../android-ndk-r27b/toolchains/llvm/prebuilt/linux-x86_64/sysroot/\u0026#34; ## Android target triple TARGET=aarch64-linux-android21 if command -v clang; then CLANG=clang elif command -v zig; then CLANG=\u0026#34;zig cc\u0026#34; else print \u0026#34;Cannot find clang or zig\\n\u0026#34; \u0026gt;\u0026amp;2 exit 1 fi ## These options are needed for llvmbox # -isystem \u0026#34;${SYSROOT}/usr/include/c++/v1\u0026#34; \\ # -isystem \u0026#34;${SYSROOT}/usr/include\u0026#34; \\ # -isystem \u0026#34;${SYSROOT}/usr/include/aarch64-linux-android\u0026#34; mkdir -p \u0026#34;${TEST_DIR}/output\u0026#34; echo \u0026#34;Test C compiler...\u0026#34; ${CLANG} \\ -B \u0026#34;${TEST_DIR}/bin\u0026#34; \\ -resource-dir \u0026#34;${RESOURCE_DIR}\u0026#34; \\ --sysroot=\u0026#34;${SYSROOT}\u0026#34; \\ --target=\u0026#34;${TARGET}\u0026#34; \\ -xc - \\ \u0026#34;$@\u0026#34; \\ -o \u0026#34;${TEST_DIR}/output/hello-c\u0026#34; \\ \u0026lt;\u0026lt;-EOF #include \u0026lt;stdio.h\u0026gt; int main() { printf(\u0026#34;%s\\n\u0026#34;, \u0026#34;Hello, C!\u0026#34;); return 0; } EOF echo \u0026#34;Test C++ compiler...\u0026#34; ${CLANG} \\ -B \u0026#34;${TEST_DIR}/bin\u0026#34; \\ -resource-dir \u0026#34;${RESOURCE_DIR}\u0026#34; \\ --sysroot=\u0026#34;${SYSROOT}\u0026#34; \\ --target=\u0026#34;${TARGET}\u0026#34; \\ -xc++ -lc++ - \\ \u0026#34;$@\u0026#34; \\ -o \u0026#34;${TEST_DIR}/output/hello-cpp\u0026#34; \\ \u0026lt;\u0026lt;-EOF #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout \u0026lt;\u0026lt; \u0026#34;Hello, C++!\\n\u0026#34;; return 0; } EOF if command -v file \u0026gt;/dev/null; then file \u0026#34;${TEST_DIR}/output/hello-c\u0026#34; \u0026#34;${TEST_DIR}/output/hello-cpp\u0026#34; fi 小贴示\n项目引用Android SDK\n测试\r在test目录下执行sh test.sh，会打印出以下日志\n1 2 3 4 5 6 /bin/clang Test C compiler... Test C++ compiler... /root/test//output/hello-c: ELF 64-bit LSB pie executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /system/bin/linker64, BuildID[xxHash]=10df539d438a8009, not stripped /root/test//output/hello-cpp: ELF 64-bit LSB pie executable, ARM aarch64, version 1 (SYSV), dynamically linked, interpreter /system/bin/linker64, BuildID[xxHash]=8ce9c24e480bcc9d, not stripped 附录\r参考文献\rNDK下载链接\nAndroid SDK\n版权信息\r本文原载于 nightrainmilkyway.cn，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-08-10T21:23:21+08:00","image":"https://img.nightrainmilkyway.cn/img/1723296375281.webp","permalink":"http://localhost:1313/p/zerotermux%E6%8A%98%E8%85%BE%E6%97%A5%E8%AE%B03-arch-linux%E4%B8%8A%E8%B7%91ndk/","title":"Zerotermux折腾日记(3)-Arch linux上跑NDK"},{"content":"使用须知\r1.安装软件或者模块之前请务必删除 asoulopt 2.使用软件和模块时请勿开启系统的性能模式开关，如果有 Extreme gt 请务必开启 3.使用模块的就没有必要安装软件 4.模块是由 scene 控制，scene 需要关闭核心分配 5.请务必安装 CuJankDetector 模块 下载\r小贴示\nGitHub release\n使用方法 1 -app 导入\r使用方法 2 -模块刷入\r检查日志\r如果为APP导入使用，即可在 APP 内查看日志 如果为模块，则 CuprumTurbo Scheduler 日志输出路径为/storage/emulated/0/Android/ct/scheduler.log 出现Daemon Running即为调度正常运行\n附录\r参考文献\r版权信息\r本文原载于 nightrainmilkyway.cn，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-08-10T21:18:22+08:00","image":"https://img.nightrainmilkyway.cn/img/1723295109779.webp","permalink":"http://localhost:1313/p/cuprumturbo-scheduler-%E4%BD%BF%E7%94%A8/","title":"CuprumTurbo Scheduler 使用"},{"content":"安装git\r1 pacman -S git 配置git\r1 2 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;youremail@example.com\u0026#34; 测试git\r1 git --version 克隆仓库\r1 git clone https://github.com/yourusername/yourrepository.git 提交代码\r1 2 3 git add . git commit -m \u0026#34;your commit message\u0026#34; git push origin master 拉取代码\r1 git pull origin master 使用ssh连接github\r生成ssh密钥\r1 ssh-keygen -t rsa -C \u0026#34;youremail@example.com\u0026#34; 添加ssh密钥到ssh-agent\r1 2 eval \u0026#34;$(ssh-agent -s)\u0026#34; ssh-add ~/.ssh/id_rsa 添加ssh密钥到github\r1 cat ~/.ssh/id_rsa.pub 测试ssh连接\r1 ssh -T git@github.com 克隆仓库\r1 git clone git@github.com:yourusername/yourrepository.git git常用命令及注释\r1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 git init # 初始化仓库 git add . # 添加所有文件到暂存区 git commit -m \u0026#34;commit message\u0026#34; # 提交暂存区文件到仓库区 git push origin master # 将本地分支推送到远程仓库 git pull origin master # 从远程仓库拉取最新代码 git status # 查看仓库状态 git log # 查看提交历史 git diff # 查看暂存区与工作区差异 git reset --hard HEAD # 回滚到最新提交 git checkout -- file # 撤销工作区修改 git branch # 查看分支 git branch \u0026lt;branch-name\u0026gt; # 创建分支 git checkout \u0026lt;branch-name\u0026gt; # 切换分支 git merge \u0026lt;branch-name\u0026gt; # 合并分支 git remote -v # 查看远程仓库信息 git remote add origin \u0026lt;repository-url\u0026gt; # 添加远程仓库 git remote remove origin # 删除远程仓库 git remote set-url origin \u0026lt;repository-url\u0026gt; # 修改远程仓库地址 git remote update origin --prune # 更新远程仓库信息 git remote show origin # 查看远程仓库详细信息 附录\r参考文献\r版权信息\r本文原载于 nightrainmilkyway.cn，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-08-10T20:58:28+08:00","image":"https://img.nightrainmilkyway.cn/img/1723295107649.webp","permalink":"http://localhost:1313/p/zerotermux%E6%8A%98%E8%85%BE%E6%97%A5%E8%AE%B02-arch-linux%E5%AE%89%E8%A3%85git/","title":"Zerotermux折腾日记(2)-Arch linux安装git"},{"content":"开始\rtermux作为一个能在Android上运行的终端模拟器，能够模拟Linux环境，重点是不需要root也可以使用，只不过局限性不是很大\n换源\u0026amp;安装tome脚本\r换清华源\r国内网络环境确实很差，官方源可能连不上，这里换源加速\n1 sed -i \u0026#39;s@^\\(deb.*stable main\\)$@#\\1\\ndeb https://mirrors.tuna.tsinghua.edu.cn/termux/termux-packages-24 stable main@\u0026#39; $PREFIX/etc/apt/sources.list \u0026amp;\u0026amp; apt update \u0026amp;\u0026amp; apt upgrade 安装tome一键脚本\r1 2 3 awk -f \u0026lt;(curl -L l.tmoe.me/2.awk) # 备用地址 awk -f \u0026lt;(curl -L gitee.com/mo2/linux/raw/2/2.awk) 在出现 您要继续吗? Do you want to continue? 之类的选项时：[Y/n]直接按回车，[y/N]输入y再回车 前面直接回车即可，直到出现选项输入 y时，输入小写的 y即可，然后等待到出现图形化界面\nDNS 推荐选择：240c::6666\n一言：推荐选择，增加观赏性\n时区(Timezone)：Asia/Shanghai 回车\n共享目录：用于在容器中访问宿主文件，默认即可\n选择一个Linux发行版安装\r如果有root权限建议安装chroot，没有root权限选择proot 推荐使用 Ubuntu , arch\n选择arm64发行版列表\n默默等待安装，中途会出现是否安装 zsh建议安装，tool如果有桌面需求可以安装，建议 xfce\nPacman 包管理\r在 archlinux 上安装的软件都通过 Pacman 来进行管理。\n为了使用 Pacman 额外的命令需要先安装 pacman-contribextra / aur。\n安装 pacman-contrib ：\n1 sudo pacman -S pacman-contrib 可以把 Pacman 理解为一个软件管理器（软件管家？），可以进行软件的安装、删除、查询等：\n1 2 3 4 5 6 7 8 9 10 11 sudo pacman -S package_name # 安装软件包 pacman -Ss # 在同步数据库中搜索包，包括包的名称和描述 sudo pacman -Syu # 升级系统。 -y:标记刷新、-yy：标记强制刷新、-u：标记升级动作（一般使用 -Syu 即可） sudo pacman -Rns package_name # 删除软件包，及其所有没有被其他已安装软件包使用的依赖包 sudo pacman -R package_name # 删除软件包，保留其全部已经安装的依赖关系 pacman -Qi package_name # 检查已安装包的相关信息。-Q：查询本地软件包数据库 pacman -Qdt # 找出孤立包。-d：标记依赖包、-t：标记不需要的包、-dt：合并标记孤立包 sudo pacman -Rns $(pacman -Qtdq) # 删除孤立包 sudo pacman -Fy # 更新命令查询文件列表数据库 pacman -F some_command # 当不知道某个命令属于哪个包时，用来在远程软件包中查询某个命令属于哪个包（即使没有安装） pactree package_name # linux终端基本命令\r1 2 3 4 5 6 7 8 9 10 ls /some_path # 查看某个文件夹下的文件与子文件夹。/ 代表根目录，是 Linux 最顶端的路径，以此开头则为绝对路径 pwd # 查看当前终端所在路径 cat /home/testuser/testfile # 以输出流方式查看某个文件 cd /home/testuser # 切换目录命令。将当前终端切换到某一个路径下 cp ./a.py ./b.py # 复制命令。将当前路径下的 a.py 复制一份并命名为 b.py。./ 代表当前文件夹所在路径，以此开头则为相对路径 cp -r ./a ./b # 复制整体文件夹 rm b.py # 删除命令。删除 b.py mv a.py b.py # 移动（重命名）命令。将 a.py 更名为 b.py mkdir my_folder # 新建名为 my_folder 的文件夹 sudo some_command # 使普通用户以 root 权限执行某些命令 终端美化\r安装 lolcat：\n1 sudo pacman -S lolcat 通过管道符（|）将其它命令（如 neofetch）的输出传递给 lolcat：\n1 neofetch | lolcat 附录\r参考文献\r版权信息\r本文原载于 nightrainmilkyway.cn，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2024-08-10T00:42:16+08:00","image":"https://img.nightrainmilkyway.cn/img/1723221912885.webp","permalink":"http://localhost:1313/p/zerotermux%E6%8A%98%E8%85%BE%E6%97%A5%E8%AE%B01-%E5%AE%89%E8%A3%85arch-linux/","title":"Zerotermux折腾日记(1)-安装arch Linux"}]